'use strict';

/**
 * 今天我们将学习所有关于数据结构的内容。
 *
 *    “哇哦，*真*令人兴奋，对吧？”
 *
 * 是的，它们确实不是最吸引人的话题，但它们非常重要。
 * 不仅仅是为了通过计算机科学基础课程，更是为了成为一个
 * 更好的程序员。
 *
 * 了解数据结构可以帮助你：
 *
 *   - 管理复杂性，使程序更易于理解。
 *   - 构建高性能、内存高效的程序。
 *
 * 我认为前者更为重要。使用合适的数据结构可以大幅简化
 * 否则会非常复杂的逻辑。
 *
 * 后者也很重要。如果性能或内存是关键，那么选择合适的数据结构
 * 通常是必不可少的。
 *
 * 为了学习数据结构，我们将一起实现其中的一些。别担心，我们会
 * 保持代码简洁。实际上，注释的部分要比代码多得多。
 */

/**
 * ============================================================================
 * ,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
 * ============================================================================
 */

/**
 * 什么是数据结构？
 *
 * 本质上，它们是存储和组织数据的不同方法，旨在满足不同的需求。
 *
 * 数据总是可以通过多种不同的方式表示。然而，具体选择哪种表示方法，
 * 取决于数据的类型以及你需要对其执行的操作。某种表示方法通常会比其他方法
 * 更适合某些场景。
 *
 * 为了理解为什么如此，我们首先来简单谈谈算法。
 */

/*** ===================================================================== ***\
 ** - ALGORITHMS ---------------------------------------------------------- **
 * ========================================================================= *
 *                                                                           *
 *                        ,--,--.    ,--,--.                                 *
 *   ,----------.        |   |   |  |   |   |            _____               *
 *  |`----------'|       |   |   |  |   |   |           |     |    ,------.  *
 *  |            |       |   |   |  |   |   |      ,--. | o o |   |`------'| *
 *  |            |      ,| +-|-+ |  | +-|-+ |`     |  | |_____|   |        | *
 *  |            | ,:==| | |###|======|###| | |====#==#====#=,,   |        | *
 *  |            | ||   `| +---+ |  | +---+ |'  ,,=#==#====O=``  ,|        | *
 *  |            | ||    |   |   |  |   |   |   ``=#==#====#=====||        | *
 *   `----------'  ||    |   |   |  |   |   |      |__|          `|        | *
 *    | | ``=| |===``    `--,',--`  `--,',--`      /||\            `------'  *
 **   \_/    \_/         / /   \ \  / /   \ \     //||\\           |_|  |_| **
\*** ===================================================================== ***/

/**
 * 算法是指一系列按步骤执行的操作。
 *
 * 数据结构是通过算法来实现的，算法则依赖于数据结构的实现。从数据结构到
 * 算法，层层相连，直到你看到那些拿着打孔卡片控制计算机的微观人物。（计算机
 * 就是这样运作的，对吧？）
 *
 * 任何任务都可以用无数种方式来实现。因此，对于常见任务，人们通常会提出
 * 多种不同的算法。
 *
 * 例如，对于排序一组无序的项，有着数不胜数的算法：
 *
 *     插入排序、选择排序、归并排序、冒泡排序、堆排序、
 *     快速排序、希尔排序、Tim排序、桶排序、基数排序……
 *
 * 其中一些算法比其他算法要快得多。一些算法使用的内存较少，
 * 有些实现起来更简单，还有一些算法是基于数据集的特定假设。
 *
 * 每种算法都有它更适合的使用场景。所以，你需要根据自己的需求做出选择，
 * 而这就需要一种比较它们的方式，一种衡量它们的方法。
 *
 * 当我们比较算法性能时，我们通常会使用一种叫做“Big-O”的方法
 * 来粗略测量它们的平均性能和最坏情况性能。
 */

/*** ===================================================================== ***\
 ** - BIG-O NOTATION ------------------------------------------------------ **
 * ========================================================================= *
 *           a           b                                 d                 *
 *           a         b    O(N^2)                      d                    *
 *     O(N!) a        b                O(N log N)    d                    c  *
 *           a      b                            d                 c         *
 *          a      b                          d             c        O(N)    *
 *          a    b                         d         c                       *
 *          a  b                       d      c                              *
 *         a  b                     d  c                                     *
 *         ab                   c                          O(1)              *
 *  e    e    e    e    ec   d    e    e    e    e    e     e    e    e      *
 *      ba        c      d                                                   *
 *    ba   c        d                       f    f    f    f    f    f    f  *
 ** cadf    f d    f    f    f    f    f       O(log N)                     **
\*** ===================================================================== ***/

/**
 * Big-O符号是一种粗略衡量算法性能的方式，用于在讨论算法时进行相互比较。
 *
 * Big-O 是我们从数学中借用的符号，计算机科学中用它来根据输入数据项的数量 (N)
 * 对算法进行分类。
 *
 * 使用 Big-O，我们通常衡量两件事：
 *
 * - **时间复杂度**指的是算法在给定一组数据项时需要执行的总操作次数。
 *
 * - **空间复杂度**指的是算法在执行时需要占用的总内存量。
 *
 * 我们独立地衡量这两者，因为有时一个算法虽然执行的操作较少，但可能会占用更多的内存。
 * 根据需求的不同，可能会有一种算法比另一种更适合。
 *
 * 下面是一些常见的 Big-O：
 *
 *     名称           符号         当它们出现在你的派对时的心情
 *     ------------------------------------------------------------------------
 *     常数           O(1)         太棒了！！
 *     对数           O(log N)     很棒！
 *     线性           O(N)         一般。
 *     线性对数       O(N log N)   嗯……
 *     多项式         O(N ^ 2)     烂透了
 *     指数           O(2 ^ N)     糟糕
 *     阶乘           O(N!)        WTF
 *
 * 为了让你理解这些操作数的数量，以下是给定不同 (N) 数据项时的对应数值：
 *
 *                N = 5            10             20             30
 *     ------------------------------------------------------------------------
 *     O(1)           1            1              1              1
 *     O(log N)       2.3219...    3.3219...      4.3219...      4.9068...
 *     O(N)           5            10             20             30
 *     O(N log N)     11.609...    33.219...      84.638...      147.204...
 *     O(N ^ 2)       25           100            400            900
 *     O(2 ^ N)       32           1024           1,048,576      1,073,741,824
 *     O(N!)          120          3,628,800      2,432,902,0... 265,252,859,812,191,058,636,308,480,000,000
 *
 * 如你所见，即使对于相对较小的数据集，你也可能需要做**大量**额外的工作。
 *
 * 对于数据结构，你可以执行四种主要操作：访问、查找、插入和删除。
 *
 * 需要注意的是，某些数据结构可能在某一操作上表现优秀，而在另一些操作上表现较差。
 *
 *                            访问         查找        插入        删除
 *    -------------------------------------------------------------------------
 *             数组        O(1)         O(N)         O(N)         O(N)
 *             链表        O(N)         O(N)         O(1)         O(1)
 *        二叉搜索树    O(log N)     O(log N)     O(log N)     O(log N)
 *
 * 或者说……
 *
 *                            访问         查找        插入        删除
 *    -------------------------------------------------------------------------
 *            数组           太棒了！！    一般        一般        一般
 *            链表           一般         一般        太棒了！！    太棒了！！
 *       二叉搜索树           很棒！       很棒！       很棒！       很棒！
 *
 * 更进一步，某些操作会有不同的“平均”性能和“最坏情况”性能。
 *
 * 没有完美的数据结构，你需要根据你处理的数据类型和将要执行的操作来选择合适的结构。
 * 这就是为什么了解多种常见数据结构很重要，以便你能在它们之间做出选择。
 */

/*** ===================================================================== ***\
 ** - MEMORY -------------------------------------------------------------- **
 * ========================================================================= *
 *                             _.-..                                         *
 *                           ,'9 )\)`-.,.--.                                 *
 *                           `-.|           `.                               *
 *                              \,      ,    \)                              *
 *                               `.  )._\   (\                               *
 *                                |//   `-,//                                *
 *                                ]||    //"                                 *
 **                        hjw    ""    ""                                  **
\*** ===================================================================== ***/

/**
 * 计算机的内存其实非常简单，它就是一组有序的槽位，用来存储信息。
 * 你通过持有内存地址来查找和访问信息。
 *
 * 让我们假设一块内存是这样的：
 *
 *      值:       |1001|0110|1000|0100|0101|1010|0010|0001|1101|1011...
 *	   地址:       0    1    2    3    4    5    6    7    8    9    ...
 *
 * 如果你曾经好奇为什么编程语言中的索引是从零开始的，那是因为内存的工作方式。
 * 如果你想读取第一块内存，你需要从地址0读取到1；第二块则是从地址1读取到2。
 * 所以你持有的地址分别是0和1。
 *
 * 你的计算机拥有的内存比这要多得多，而且这所有的内存都遵循上面的模式。
 *
 * 内存有点像西部的荒野，每个在你机器上运行的程序都存储在同一个*物理*数据结构中。
 * 如果没有层层抽象，直接使用这些内存会非常困难。
 *
 * 但这些抽象服务于两个额外的目的：
 *
 *   - 以更高效和/或更快速的方式存储数据到内存中，以便进行操作。
 *   - 以更易于使用的方式存储数据到内存中，简化操作。
 */

/*** ===================================================================== ***\
 ** - LISTS --------------------------------------------------------------- **
 * ========================================================================= *
 *                  *     _______________________                            *
 *                    ()=(_______________________)=()           *            *
 *       *                |                     |                            *
 *                        |   ~ ~~~~~~~~~~~~~   |       *               *    *
 *             *          |                     |                            *
 *   *                    |   ~ ~~~~~~~~~~~~~   |         *                  *
 *                        |                     |                            *
 *                        |   ~ ~~~~~~~~~~~~~   |                 *          *
 *        *               |                     |                            *
 *                   *    |_____________________|         *        *         *
 *                    ()=(_______________________)=()                        *
 **                                                                         **
\*** ===================================================================== ***/

/**
 * 为了演示内存与数据结构之间的原始交互，我们将首先实现一个列表。
 *
 * 列表是一个有序的值序列表示，允许相同的值出现多次。
 */

class List {
	/**
	 * 我们从一个空的内存块开始，这个内存块将用普通的 JavaScript 数组来表示，
	 * 并且我们会单独存储列表的长度。
	 *
	 * 请注意，我们希望单独存储长度，因为在实际应用中，"内存"并没有一个可以读取的长度。
	 */

	constructor() {
		this.memory = [];
		this.length = 0;
	}

	/**
	 * 首先，我们需要一种方法来从列表中获取数据。
	 *
	 * 对于一个简单的列表，你可以非常快速地访问内存，因为你直接跟踪内存地址。
	 *
	 * 列表的访问是常数时间 O(1) —— “太棒了！！”
	 */

	get(address) {
		return this.memory[address];
	}

	/**
	 * 由于列表是有顺序的，你可以在列表的开始、中间或末尾插入元素。
	 *
	 * 在我们的实现中，我们将专注于通过以下四个方法在列表的开始或末尾添加和删除值：
	 *
	 *   - Push    - 将值添加到末尾
	 *   - Pop     - 从末尾删除一个值
	 *   - Unshift - 将值添加到开头
	 *   - Shift   - 从开头删除一个值
	 */

	/*
	 * 从“push”开始，我们需要一种方法将项目添加到列表的末尾。
	 *
	 * 这很简单，只需在列表末尾的地址后添加一个值。由于我们存储了长度，因此
	 * 计算位置很容易。我们只需添加值并增加长度。
	 *
	 * 将项目推送到列表的末尾是常数时间 O(1) —— “太棒了！！”
	 */

	push(value) {
		this.memory[this.length] = value;
		this.length++;
	}

	/**
	 * 接下来，我们需要一种方法从列表的末尾“弹出”项目。
	 *
	 * 与 push 类似，我们只需删除列表末尾地址处的值，然后减少长度。
	 *
	 * 从列表末尾弹出项目是常数时间 O(1) —— “太棒了！！”
	 */

	pop() {
		// 如果列表为空，什么也不做。
		if (this.length === 0) return;

		// 获取最后一个值，停止存储它，并返回该值。
		let lastAddress = this.length - 1;
		let value = this.memory[lastAddress];
		delete this.memory[lastAddress];
		this.length--;

		// 同时返回该值，以便可以使用。
		return value;
	}

	/**
	 * “push”和“pop”都操作列表的末尾，总体来说它们是相当简单的操作，因为它们不需要考虑列表的其余部分。
	 *
	 * 让我们看看当我们操作列表的开头时，“unshift”和“shift”会发生什么。
	 */

	/**
	 * 为了在列表的开头添加一个新项目，我们需要通过将所有现有值向右滑动一位来为新值腾出空间。
	 *
	 *     [a, b, c, d, e]
	 *      0  1  2  3  4
	 *       ⬊  ⬊  ⬊  ⬊  ⬊
	 *         1  2  3  4  5
	 *     [x, a, b, c, d, e]
	 *
	 * 为了将所有项目滑动一位，我们需要遍历每个元素并将其前一个值移动过来。
	 *
	 * 因为我们必须遍历列表中的每一个项目：
	 *
	 * 将一个项目插入列表的开头是线性时间 O(N) —— “还行。”
	 */

	unshift(value) {
		// 存储我们将要添加到开头的值。
		let previous = value;

		// 遍历每个项目...
		for (let address = 0; address < this.length; address++) {
			// 将“current”值替换为“previous”值，并为下一次迭代存储“current”值。
			let current = this.memory[address];
			this.memory[address] = previous;
			previous = current;
		}

		//在列表末尾的新位置添加最后一项
		this.memory[this.length] = previous;
		this.length++;
	}

	/**
	 * 最后，我们需要编写一个 shift 函数来朝相反的方向移动。
	 *
	 * 我们删除第一个值，然后遍历列表中的每个项目，将它们下移一个地址。
	 *
	 *     [x, a, b, c, d, e]
	 *         1  2  3  4  5
	 *       ⬋  ⬋  ⬋  ⬋  ⬋
	 *      0  1  2  3  4
	 *     [a, b, c, d, e]
	 *
	 * 从列表开头移除一个项目是线性时间 O(N) —— “还行。”
	 */

	shift() {
		// 如果列表为空，什么也不做
		if (this.length === 0) return;

		let value = this.memory[0];

		// 遍历每个项目...
		for (let address = 0; address < this.length - 1; address++) {
			// 并将它们替换为列表中的下一个项目。
			this.memory[address] = this.memory[address + 1];
		}

		// 删除最后一个项目，因为它现在位于前一个地址。
		delete this.memory[this.length - 1];
		this.length--;

		return value;
	}
}

/**
 * 列表非常适合快速访问和处理末尾的项目。然而，
 * 正如我们所看到的，它不太适合处理非末尾的项目，并且我们必须手动保持内存地址。
 *
 * 所以让我们来看看另一种数据结构，以及它是如何处理添加、访问和删除值的，而不需要知道内存地址。
 */

/*** ===================================================================== ***\
 ** - HASH TABLES --------------------------------------------------------- **
 * ========================================================================= *
 *                           ((\                                             *
 *     (              _  ,-_  \ \                                            *
 *     )             / \/  \ \ \ \                                           *
 *     (            /)| \/\ \ \| |          .'---------------------'.        *
 *     `~()_______)___)\ \ \ \ \ |        .'                         '.      *
 *                 |)\ )  `' | | |      .'-----------------------------'.    *
 *                /  /,          |      '...............................'    *
 *        ejm     |  |          /         \   _____________________   /      *
 *                \            /           | |_)                 (_| |       *
 *                 \          /            | |                     | |       *
 *                  )        /             | |                     | |       *
 **                /       /              (___)                   (___)     **
\*** ===================================================================== ***/

/**
 * 哈希表是一种*无序*的数据结构。相反，我们有“keys”和“values”，我们使用键计算出内存中的地址。
 *
 * 基本的思路是我们有可以“哈希化”的键（稍后会介绍），这些键可以用来非常高效地添加、访问和删除内存中的数据。
 *
 *     var hashTable = new HashTable();
 *
 *     hashTable.set('myKey', 'myValue');
 *     hashTable.get('myKey'); // >> 'myValue'
 */

class HashTable {
	//我们将再次使用一个普通的 JavaScript 数组来表示我们的内存

	constructor() {
		this.memory = [];
	}

	/**
	 * 为了在哈希表的内存中存储键值对，我们需要一种方法来将键转换为地址。我们通过一种叫做“哈希”的操作来实现这一点。
	 *
	 * 基本上，它将一个键序列化为该键的唯一数字。
	 *
	 *    hashKey("abc") =>  96354
	 *    hashKey("xyz") => 119193
	 *
	 * 然而，你必须小心，如果键非常大，你不希望将其匹配到一个不存在的内存地址。
	 *
	 * 因此，哈希算法需要限制大小，这意味着有限的地址只能映射到无限数量的值。
	 *
	 * 结果是，你可能会遇到碰撞的情况。即两个键被转换为相同的地址。
	 *
	 * 任何实际的哈希表实现都必须处理这个问题，然而，我们将简单地忽略它，假装这种情况不会发生。
	 */

	/**
	 * 让我们设置我们的“hashKey”函数。
	 *
	 * 不必担心理解这个函数的逻辑，只需要知道它接受一个字符串并输出一个（大致）唯一的地址，我们将在其他所有函数中使用它。
	 */

	hashKey(key) {
		let hash = 0;
		for (let index = 0; index < key.length; index++) {
			// Oh look– magic.
			let code = key.charCodeAt(index);
			hash = ((hash << 5) - hash + code) | 0;
		}
		return hash;
	}

	/**
	 * 接下来，让我们定义我们的“get”函数，以便通过键访问值。
	 *
	 * HashTable 的访问是常数 O(1) - "太棒了！！"
	 */

	get(key) {
		// 我们首先将键转化为一个地址。
		let address = this.hashKey(key);
		// 然后，我们只需返回该地址处的内容。
		return this.memory[address];
	}

	/**
	 * 我们还需要一种在访问数据之前添加数据的方法，因此我们将创建一个“set”函数来插入值。
	 *
	 * 哈希表设置的时间复杂度是常数 O(1) - “太棒了！！”
	 */

	set(key, value) {
		//同样，我们首先将 key 转换为地址。
		let address = this.hashKey(key);
		// 然后只需将值设置到该地址。
		this.memory[address] = value;
	}

	/**
	 * 最后，我们只需要一种从哈希表中删除项的方法。
	 *
	 * 哈希表删除操作是常数时间 O(1) - "AWESOME!!"
	 */

	remove(key) {
		//与往常一样，我们对 key 进行哈希处理以获取地址。
		let address = this.hashKey(key);
		// 然后，如果它存在，我们 “remove” 它。
		if (this.memory[address]) {
			delete this.memory[address];
		}
	}
}

/**
 * ============================================================================
 * ,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
 * ============================================================================
 */

/**
 	从这一点开始，我们将不再直接与内存进行交互，因为接下来的数据结构将开始使用其他数据结构进行实现。

	这些数据结构的核心目标是：

	根据数据的使用方式对其进行组织
	抽象掉实现细节
	这些数据结构旨在为各种类型的程序创建一种合理的组织方式。它们引入了一种语言，使得更复杂的逻辑能够被讨论。所有这些都在抽象实现细节的同时，使得其实现可以不断优化，提升执行效率。
 */

/*** ===================================================================== ***\
 ** - STACKS -------------------------------------------------------------- **
 * ========================================================================= *
 *                             _ . - - -- .. _                               *
 *         ||||            .-'      /```\     `'-_             /|            *
 *         ||||           (     /`` \___/ ```\    )           | |            *
 *         \__/           |`"-//..__     __..\\-"`|           | |            *
 *          ||            |`"||...__`````__...||"`|           | |            *
 *          ||            |`"||...__`````__...||"`|           \ |            *
 *          ||       _,.--|`"||...__`````__...||"`|--.,_       ||            *
 *          ||    .'`     |`"||...__`````__...||"`|     `'.    ||            *
 *          ||   '.        `/ |...__`````__...| \         .'   ||            *
 *          ||     `'-..__  ``      `````      ``  __..-'`     ||            *
 *                        `""---,,,_______,,,---""`                          *
 **                                                                         **
\*** ===================================================================== ***/

/**
 * 栈与列表有相似之处，它们都遵循一定的顺序，但栈限制你只能在列表的末端进行推入（push）和弹出（pop）操作，
 * 正如我们之前所见，这些操作在直接映射到内存时是非常迅速的。
 *
 * 然而，栈也可以通过其他数据结构来实现，以便为它们增添额外的功能。
 *
 * 栈最常见的用途是在这样的场景中：一个进程向栈中添加项目，而另一个进程则从栈的末端移除项目——
 * 优先处理最近添加的项目。
 */

class Stack {
	/**
	 * 我们将再次使用 JavaScript 数组作为底层支持，但这一次它代表的是我们之前实现的列表，而非内存空间。
	 */

	constructor() {
		this.list = [];
		this.length = 0;
	}

	/**
	 * 我们将实现列表中的两个函数：“push”和“pop”，
	 * 它们在功能上与列表中的对应操作完全相同。
	 */

	/**
	 * 使用“push”将项目添加到栈的顶部。
	 */

	push(value) {
		this.length++;
		this.list.push(value);
	}

	/**
	 * 使用“pop”从栈的顶部移除项目。
	 */

	pop() {
		// 如果列表为空，什么也不做
		if (this.length === 0) return;

		// 从列表末尾移除最后一个元素并返回其值。
		this.length--;
		return this.list.pop();
	}

	/**
	 * 我们还将添加一个函数，用于查看栈顶的元素，
	 * 而不将其从栈中移除。
	 */

	peek() {
		// 返回“items”中的最后一个元素，但不移除它。
		return this.list[this.length - 1];
	}
}

/*** ===================================================================== ***\
 ** - QUEUES -------------------------------------------------------------- **
 * ========================================================================= *
 *                   /:""|                     ,@@@@@@.                      *
 *                  |: oo|_                   ,@@@@@`oo                      *
 *                  C     _)                  @@@@C   _)                     *
 *                    ) /                     "@@@@ '=                       *
 *                   /`\\                      ```)/                         *
 *                  || | |                       /`\\                        *
 *                  || | |                      || | \                       *
 *                  ||_| |                      || | /                       *
 *                  \( ) |                      ||_| |                       *
 *               |~~~`-`~~~|                    |))) |                       *
 *         (_)   |         |         (_)        |~~~/          (_)           *
 *         | |`""....__     __....""`| |`""...._|| /  __....""`| |           *
 *         | |`""....__`````__....""`| |`""....__`````__....""`| |           *
 *         | |       | ||```         | |        ||`|``         | |           *
 *         | |       |_||__          | |        ||_|__         | |           *
 *        ,| |, jgs  (____))        ,| |,       ((;:;:)       ,| |,          *
 **       `---`                     `---`                     `---`         **
\*** ===================================================================== ***/

/**
 * 接下来，我们将构建一个与栈互补的队列。
 * 不同的是，这次我们是从队列的开头移除元素，
 * 而不是末尾。移除的是最早加入的元素，而不是最新的。
 *
 * 同样，由于这限制了功能范围，实现方式有很多种。
 * 一个不错的方式是使用链表，我们稍后会看到。
 */

class Queue {
	/**
	 * Again, our queue is using a JavaScript array as a list rather than memory.
	 */

	constructor() {
		this.list = [];
		this.length = 0;
	}

	/**
	 * 与栈类似，我们将定义两个函数来添加和移除队列中的元素。
	 * 第一个是“入队”（enqueue）。
	 *
	 * 这个函数会将值添加到列表的末尾。
	 */

	enqueue(value) {
		this.length++;
		this.list.push(value);
	}

	/**
	 * 接下来是“dequeue”，与从列表末尾移除项不同，
	 * 我们将从列表的开头移除项。
	 */

	dequeue() {
		// 如果列表为空，什么也不做
		if (this.length === 0) return;

		// 将列表开头的第一项移出并返回其值。
		this.length--;
		return this.list.shift();
	}

	/**
	 * 与栈类似，我们将定义一个“peek”函数，
	 * 用于获取下一个值而不将其从队列中移除。
	 */

	peek() {
		return this.list[0];
	}
}

/**
 * 需要特别注意的是，由于我们采用列表来实现队列，因此它继承了列表中“shift”操作的性能特性，也就是线性时间 O(N) ——暂且如此。
 *
 * 稍后我们会介绍链表的应用，从而实现一个性能更优的队列。
 */

/**
 * ============================================================================
 * ,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
 * ============================================================================
 */

/**
 * 从这里开始，我们将要处理一些数据结构，
 * 这些结构中的值会相互引用。
 *
 *    +- Data Structure ---------------------------------------+
 *    |  +- Item A ---------------+ +- Item B ---------------+ |
 *    |  | Value: 1               | | Value: 2               | |
 *    |  | Reference to: (Item B) | | Reference to: (Item A) | |
 *    |  +------------------------+ +------------------------+ |
 *    +--------------------------------------------------------+
 *
 * 数据结构中的值本身就像是小型的数据结构，因为它们不仅包含一个值，还带有额外的信息，比如指向整个数据结构中其他项的引用。你马上就会明白我的意思。
 */

/*** ===================================================================== ***\
 ** - GRAPHS -------------------------------------------------------------- **
 * ========================================================================= *
 *                                                                           *
 *   |                                 RICK ASTLEY'S NEVER GONNA...          *
 *   |       +-+                                                             *
 *   |  +-+  |-|                          [^] - GIVE YOU UP                  *
 *   |  |^|  |-|                 +-+      [-] - LET YOU DOWN                 *
 *   |  |^|  |-|       +-+       |*|      [/] - RUN AROUND AND DESERT YOU    *
 *   |  |^|  |-|  +-+  |\|       |*|      [\] - MAKE YOU CRY                 *
 *   |  |^|  |-|  |/|  |\|  +-+  |*|      [.] - SAY GOODBYE                  *
 *   |  |^|  |-|  |/|  |\|  |.|  |*|      [*] - TELL A LIE AND HURT YOU      *
 *   |  |^|  |-|  |/|  |\|  |.|  |*|                                         *
 *   +--------------------------------                                       *
 **                                                                         **
\*** ===================================================================== ***/

/**
 * 与上面的ASCII图示不同，图（graph）并不是某种视觉图表。
 *
 * 你可以这样想象：
 *
 *     A –→ B ←–––– C → D ↔ E
 *     ↑    ↕     ↙ ↑     ↘
 *     F –→ G → H ← I ––––→ J
 *          ↓     ↘ ↑
 *          K       L
 *
 * 我们有一堆‘节点’（A、B、C、D……），它们之间用线连接起来。
 *
 * 这些节点的样子大概是这样的：
 *
 *     Node {
 *       value: ...,
 *       lines: [(Node), (Node), ...]
 *     }
 *
 * 整个图的结构将如下所示：
 *
 *     Graph {
 *       nodes: [
 *         Node {...},
 *         Node {...},
 *         ...
 *       ]
 *     }
 */

class Graph {
	/**
	 * 我们会用一个普通的 JavaScript 数组来存储所有的节点。这并不是因为节点之间有什么特定的顺序，而是因为我们需要一种方式来保存对所有节点的引用。
	 */

	constructor() {
		this.nodes = [];
	}

	/**
	 * 我们可以通过创建没有连接线的节点，
	 * 来开始向图中添加值。
	 */

	addNode(value) {
		return this.nodes.push({
			value,
			lines: [],
		});
	}

	/**
	 * 接下来，我们需要能够在图中查找节点。大多数情况下，你会在图的基础上使用另一种数据结构，
	 * 以便加快搜索速度。
	 *
	 * 但在我们的例子中，我们只是简单地遍历所有节点，找到与目标值匹配的那个节点。
	 * 这是一种较慢的方式，但目前来说它是可行的。
	 */

	find(value) {
		return this.nodes.find((node) => {
			return node.value === value;
		});
	}

	/**
	 * 接下来，我们可以通过从一个节点到另一个节点画一条‘线’来连接这两个节点。
	 */

	addLine(startValue, endValue) {
		//找到每个值对应的节点。
		let startNode = this.find(startValue);
		let endNode = this.find(endValue);

		//如果找不到其中一个或另一个节点，就直接报错。
		if (!startNode || !endNode) {
			throw new Error('Both nodes need to exist');
		}

		// 并从 startNode 添加对 endNode 的引用。
		startNode.lines.push(endNode);
	}
}

/**
 * 最后，您可以使用如下所示的图表：
 *
 *     var graph = new Graph();
 *     graph.addNode(1);
 *     graph.addNode(2);
 *     graph.addLine(1, 2);
 *     var two = graph.find(1).lines[0];
 *
 * 这看起来像是做了很多工作却只实现了很少的功能，但实际上这是一种非常强大的模式，
 * 尤其是在处理复杂程序时，它能帮助保持代码的清晰性。
 * 图的强大之处在于它优化了数据之间的连接关系，而不是直接操作数据本身。
 * 一旦你拥有了图中的一个节点，就可以非常简单地找到图中所有相关的项。
 * 许多事物都可以用这种方式表示，比如用户和他们的朋友、node_modules 文件夹中的 800 个传递依赖，
 * 甚至互联网本身也是一个由网页通过链接连接而成的图。
 */

/*** ===================================================================== ***\
 ** - LINKED LISTS -------------------------------------------------------- **
 * ========================================================================= *
 *      _______________________                                              *
 *  ()=(_______________________)=()              ,-----------------,_        *
 *      |                     |               ,"                      ",     *
 *      |   ~ ~~~~~~~~~~~~~   |             ,'    ,---------------,     `,   *
 *      |               ,----------------------------,          ,----------- *
 *      |   ~ ~~~~~~~~ |                              |        |             *
 *      |               `----------------------------'          `----------- *
 *      |   ~ ~~~~~~~~~~~~~   |            `,    `----------------'     ,'   *
 *      |                     |              `,                      ,'      *
 *      |_____________________|                 `------------------'         *
 *  ()=(_______________________)=()                                          *
 **                                                                         **
\*** ===================================================================== ***/

/**
 * 接下来，我们将看到一种类似图的结构如何帮助优化有序数据列表。
 *
 * 链表是一种非常常见的数据结构，常用于实现其他数据结构，因为它能够高效地在开头、中间和末尾添加数据。
 *
 * 链表的基本思想与图类似。你有一些节点，这些节点指向其他节点。它们看起来大概是这样的：
 *
 *     1 -> 2 -> 3 -> 4 -> 5
 *
 * 将它们可视化为类似 JSON 的结构如下所示：
 *
 *     {
 *       value: 1,
 *       next: {
 *         value: 2,
 *         next: {
 *           value: 3,
 *           next: {...}
 *         }
 *       }
 *     }
 */

class LinkedList {
	/**
	 * 与图不同，链表有一个单独的节点作为整个链的起点，这个节点被称为链表的“头节点”。
	 *
	 * 我们还需要记录链表的长度。
	 */

	constructor() {
		this.head = null;
		this.length = 0;
	}

	/**
	 * 首先，我们需要一种方法来获取给定位置的值。
	 *
	 * 这与普通列表的工作方式不同，因为我们不能直接跳到正确的位置。
	 * 相反，我们需要逐个节点遍历。
	 */

	get(position) {
		// 如果位置超出了链表的长度，就抛出一个错误。
		if (position >= this.length) {
			throw new Error('Position outside of list range');
		}

		// 从列表的头部开始。
		let current = this.head;

		// 通过 node.next 逐个遍历所有节点，直到到达指定位置。
		for (let index = 0; index < position; index++) {
			current = current.next;
		}

		// 返回我们找到的节点。
		return current;
	}

	/**
	 * 接下来，我们需要一种方法将节点添加到指定位置。
	 *
	 * 我们将实现一个通用的添加方法，它接受一个值和位置作为参数。
	 */

	add(value, position) {
		// 首先创建一个节点来保存我们的值。
		let node = {
			value,
			next: null,
		};

		// 对于插入到头节点位置的情况，我们需要特殊处理。
		// 我们将新节点的“next”字段指向当前的头节点，然后用新节点替换它
		if (position === 0) {
			node.next = this.head;
			this.head = node;

			// 如果我们要在任意其他位置添加节点，需要将其插入到当前节点和前一个节点之间
		} else {
			// 首先，找到前一个节点和当前节点
			let prev = this.get(position - 1);
			let current = prev.next;
			// 然后，通过设置新节点的 "next" 指向当前节点，
			// 并更新前一个节点的 "next" 指向新节点，
			// 将新节点插入到它们之间
			node.next = current;
			prev.next = node;
		}

		// 最后，只需将长度加一即可
		this.length++;
	}

	/**
	 * 我们需要的最后一个方法是移除方法。我们将通过位置查找节点，并将其从链中移除。
	 */

	remove(position) {
		// 我们不能从空列表中移除节点
		if (!this.head) {
			throw new Error('Removing from empty list');
		}
		// 如果要移除第一个节点，只需将头节点指向链表中的下一个节点。
		if (position === 0) {
			this.head = this.head.next;

			// 对于其他位置，我们需要找到前一个节点，并将其 "next" 指向当前节点的下一个节点。
		} else {
			let prev = this.get(position - 1);
			prev.next = prev.next.next;
		}

		// 然后将长度减一即可
		this.length--;
	}
}

/**
 * ============================================================================
 * ,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'`'-.,.-'
 * ============================================================================
 */

/**
 * 我们接下来要介绍的两种数据结构都属于“树”这一类。
 *
 * 就像现实世界中的树木一样，树形数据结构也有许多不同的类型。
 *
 *     Binary Trees:
 *       AA Tree, AVL Tree, Binary Search Tree, Binary Tree, Cartesian Tree,
 *       left child/right sibling tree, order statistic tree, Pagoda, ...
 *
 *     B Trees:
 *       B Tree, B+ Tree, B* Tree, B Sharp Tree, Dancing Tree, 2-3 Tree, ...
 *
 *     Heaps:
 *       Heap, Binary Heap, Weak Heap, Binomial Heap, Fibonacci Heap, Leonardo
 *       Heap, 2-3 Heap, Soft Heap, Pairing Heap, Leftist Heap, Treap, ...
 *
 *     Trees:
 *       Trie, Radix Tree, Suffix Tree, Suffix Array, FM-index, B-trie, ...
 *
 *     Multi-way Trees:
 *       Ternary Tree, K-ary tree, And-or tree, (a,b)-tree, Link/Cut Tree, ...
 *
 *     Space Partitioning Trees:
 *       Segment Tree, Interval Tree, Range Tree, Bin, Kd Tree, Quadtree,
 *       Octree, Z-Order, UB-Tree, R-Tree, X-Tree, Metric Tree, Cover Tree, ...
 *
 *     Application-Specific Trees:
 *       Abstract Syntax Tree, Parse Tree, Decision Tree, Minimax Tree, ...
 *
 * 你可能没想到今天会学习树木学……而且这些还不是全部。不过别被这些吓到，大多数树结构其实并不重要。只是有很多计算机科学博士需要证明自己的价值。
 *
 * 树与图或链表非常相似，只是它们是“单向”的。这意味着它们不能有循环引用。
 *
 *        Tree:                Not a Tree:
 *
 *          A                        A
 *        ↙   ↘                    ↗   ↘
 *      B       C                B ←–––– C
 *
 * 如果你能在树的连接节点之间画出一个循环……那它就不是一棵树了。
 *
 * 树有很多不同的用途，它们可以用来优化搜索或排序，更好地组织程序结构，或者提供一种更易于操作的表示形式。
 */

/*** ===================================================================== ***\
 ** - TREES --------------------------------------------------------------- **
 * ========================================================================= *
 *            ccee88oo             \ | /                                     *
 *          C8O8O8Q8PoOb o8oo    '-.;;;.-,   ooooO8O8QOb o8bDbo              *
 *        dOB69QO8PdUOpugoO9bD  -==;;;;;==-aadOB69QO8PdUOpugoO9bD            *
 *       CgggbU8OU qOp qOdoUOdcb .-';;;'-.  CgggOU ddqOp qOdoUOdcb           *
 *           6OuU  /p u gcoUodpP   / | \ jgs  ooSec cdac pdadfoof            *
 *             \\\//  /douUP         '         \\\d\\\dp/pddoo               *
 *               \\\////                         \\ \\////                   *
 *                |||/\                           \\///                      *
 *                |||\/                           ||||                       *
 *                |||||                          /|||                        *
 ** .............//||||\.......................//|||\\..................... **
\*** ===================================================================== ***/

/**
 * 我们将从一个非常简单的树结构开始。它没有任何特殊的规则，看起来大概是这样的：
 *
 *     Tree {
 *       root: {
 *         value: 1,
 *         children: [{
 *           value: 2,
 *           children: [...]
 *         }, {
 *           value: 3,
 *           children: [...]
 *         }]
 *       }
 *     }
 */

class Tree {
	/**
	 * 树必须从一个单独的父节点开始，这个节点被称为树的“根节点”。
	 */

	constructor() {
		this.root = null;
	}

	/**
	 * 我们需要一种方法来遍历树，并对树中的每个节点调用一个函数
	 */

	traverse(callback) {
		// 我们将定义一个 walk 函数，它可以递归地调用树中的每个节点。
		function walk(node) {
			// 首先对节点调用回调函数
			callback(node);
			// 然后递归地对所有子节点调用 walk 函数。
			node.children.forEach(walk);
		}

		// 现在开始遍历过程
		walk(this.root);
	}

	/**
	 * 接下来，我们需要一种方法向树中添加节点。
	 */

	add(value, parentValue) {
		let newNode = {
			value,
			children: [],
		};

		// 如果没有根节点，就将其设置为新节点
		if (this.root === null) {
			this.root = newNode;
			return;
		}

		// 否则遍历整个树，找到值匹配的节点，并将新节点添加到其子节点中
		this.traverse((node) => {
			if (node.value === parentValue) {
				node.children.push(newNode);
			}
		});
	}
}

/**
 * 这是你能实现的最基础的树结构之一，可能只有在表示的数据确实类似于树时才有用。
 *
 * 但通过添加一些额外的规则，树可以用于许多不同的场景。
 */

/*** ===================================================================== ***\
 ** - BINARY SEARCH TREES ------------------------------------------------- **
 * ========================================================================= *
 * 0 0 1 0 1 0 0 1 0 1 1 1 0 1  ,@@@@@@@@@@@@@@,   0 0 1 0 1 0 0 1 0 1 1 1 0 *
 * 0 1 0 1 0 1 0 1 1 0 1 1 0  @@`              '@@   0 1 0 1 0 1 1 0 1 0 1 0 *
 * 1 1 0 0 0 1 0 0 1 1 1 0  @@`   8O8PoOb o8o    '@@   0 0 1 0 0 1 0 0 1 1 1 *
 * 0 0 1 1 0 1 0 1 0 0 0  @@   dOB69QO8PdUgoO9bD    @@   1 0 1 1 0 1 0 1 0 0 *
 * ===================== @@   CgbU8OU qOp qOdOdcb    @@  0 1 1 0 1 0 1 0 1 0 *
 *                       @@      6OU /p u gcoUpP     @@  1 0 1 1 0 1 0 0 1 1 *
 * ===================== @@         \\// /doP        @@  0 1 1 0 0 1 0 0 1 0 *
 * 1 1 0 0 1 1 0 1 1 0 0  @@         \\//           @@   1 0 1 0 0 1 1 0 1 1 *
 * 0 1 1 0 1 0 1 1 0 1 1 0  @@,      |||          ,@@  0 1 1 0 1 1 0 0 1 0 1 *
 * 1 0 1 0 1 1 0 0 1 0 0 1 0  @@,   //|\       ,@@   0 1 0 1 0 1 1 0 0 1 1 0 *
 **  1 0 1 0 0 1 1 0 1 0 1 0 1  `@@@@@@@@@@@@@@'   0 1 1 1 0 0 1 0 1 0 1 1  **
\*** ===================================================================== ***/

/**
 * 二叉搜索树是一种相当常见的树结构，因为它能够高效地访问、搜索、插入和删除值，同时保持数据的有序性。
 *
 *
 * 想象一下有一组数字序列：
 *
 *     1  2  3  4  5  6  7
 *
 * 然后从中间开始将其转换为一棵树
 *
 *              4
 *           /     \
 *        2           6
 *      /   \       /   \
 *     1     3     5     7
 *    -^--^--^--^--^--^--^-
 *     1  2  3  4  5  6  7
 *
 * 这就是二叉树的工作原理。每个节点可以有两个子节点：
 *
 * - 左子节点：小于父节点的值。
 * - 右子节点：大于父节点的值。
 *
 * > 注意：为了实现这一点，树中的所有值必须是唯一的。
 *
 * 这使得查找值的遍历过程非常高效。假设我们试图在树中找到数字 5：
 *
 *             (4)         <--- 5 > 4, so move right.
 *           /     \
 *        2         (6)    <--- 5 < 6, so move left.
 *      /   \       /   \
 *     1     3    (5)    7 <--- We've reached 5!
 *
 * 注意我们只需要进行 3 次检查就能找到数字 5。如果我们将这棵树扩展到 1000 个节点，过程会是这样的：
 *
 *   500 -> 250 -> 125 -> 62 -> 31 -> 15 -> 7 -> 3 -> 4 -> 5
 *
 * 对于 1000 个节点，只需要 10 次检查！
 *
 * 关于二叉搜索树的另一个重要特点是，它们类似于链表，因为在添加或移除一个值时，你只需要更新直接相邻的节点。
 */

class BinarySearchTree {
	/**
	 * 与之前的树一样，我们需要有一个二叉搜索树的“根”节点。
	 */

	constructor() {
		this.root = null;
	}

	/**
	 * 为了测试值是否存在于树中，我们首先需要在树中进行查找。
	 */

	contains(value) {
		// 我们从根节点开始
		let current = this.root;

		// 只要还有节点可以访问，我们就会继续运行。
		// 如果我们遇到 `left` 或 `right` 为 `null`，则循环结束。
		while (current) {
			// 如果该值大于当前节点的值，我们就向右移动。
			if (value > current.value) {
				current = current.right;

				//如果该值小于当前节点的值，我们就向左移动
			} else if (value < current.value) {
				current = current.left;

				// 否则，两者的值必定相等，我们便返回 true
			} else {
				return true;
			}
		}

		// 如果没有任何匹配项，我们就返回 false
		return false;
	}

	/**
	 * 为了向这棵树添加元素，我们将执行与之前相同的遍历操作，根据待添加元素的值是小于还是大于当前节点，来决定是向左还是向右移动。
	 *
	 * 不过这一次，当我们遇到 `left` 或 `right` 为 `null` 时，我们就在那个位置插入一个新节点
	 */

	add(value) {
		// 首先，让我们设置我们的节点
		let node = {
			value: value,
			left: null,
			right: null,
		};

		// 特殊情况：当根节点不存在时，我们只需直接添加一个根节点
		if (this.root === null) {
			this.root = node;
			return;
		}

		// 我们从根节点开始
		let current = this.root;

		// 我们将持续循环，直到添加了元素或发现它已经存在于树中为止。
		while (true) {
			// 如果该值大于当前节点的值，我们就向右移动。
			if (value > current.value) {
				// 如果 `right` 不存在，将其设置为我们的节点，并停止遍历。
				if (!current.right) {
					current.right = node;
					break;
				}

				// 否则，直接移动到右节点。
				current = current.right;

				// 如果该值小于当前节点的值，我们就向左移动。
			} else if (value < current.value) {
				// 如果 `left` 不存在，将其设置为我们的节点，并停止遍历。
				if (!current.left) {
					current.left = node;
					break;
				}

				// 否则，直接移动到左节点。
				current = current.left;

				// 如果该值既不小于也不大于当前节点的值，那么它必定是相同的值，我们无需进行任何操作。
			} else {
				break;
			}
		}
	}
}

/*** ===================================================================== ***\
 ** - YOU REACHED THE END! ------------------------------------------------ **
 * ========================================================================= *
 *                                           .''.                            *
 *                 .''.             *''*    :_\/_:     .                     *
 *                :_\/_:   .    .:.*_\/_*   : /\ :  .'.:.'.                  *
 *            .''.: /\ : _\(/_  ':'* /\ *  : '..'.  -=:o:=-                  *
 *           :_\/_:'.:::. /)\*''*  .|.* '.\'/.'_\(/_'.':'.'                  *
 *           : /\ : :::::  '*_\/_* | |  -= o =- /)\    '  *                  *
 *            '..'  ':::'   * /\ * |'|  .'/.\'.  '._____                     *
 *                *        __*..* |  |     :      |.   |' .---"|             *
 *                 _*   .-'   '-. |  |     .--'|  ||   | _|    |             *
 *              .-'|  _.|  |    ||   '-__  |   |  |    ||      |             *
 *              |' | |.    |    ||       | |   |  |    ||      |             *
 * _____________|  '-'     '    ""       '-'   '-.'    '`      |____________ *
 ** jgs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ **
\*** ===================================================================== ***/

/**
 * I know that was probably a bit dense, but hopefully it gave you a good
 * amount of knowledge. If you enjoyed it, would you mind giving the repo a
 * star and follow me on twitter (@thejameskyle)?
 *
 * You can also check out my other code walkthrough, "The Super Tiny Compiler"
 *       here ------> https://github.com/thejameskyle/the-super-tiny-compiler
 */

// Just exporting everything for the tests...
export {
	List,
	HashTable,
	Stack,
	Queue,
	Graph,
	LinkedList,
	Tree,
	BinarySearchTree,
};
